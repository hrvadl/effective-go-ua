## Зміст
- [Ініціалізація](#Ініціалізація)
  - [Константи](#Константи)
  - [Змінні](#Змінні)
  - [Функція init](#Функція-init)

## Ініціалізація
Ініціалізація в мові Go є більш потужною, ніж у C або C++. Під час ініціалізації можна будувати складні структури, а питання порядку серед ініціалізованих об'єктів, навіть серед різних пакетів, вирішуються коректно.

### Константи
Константи у Go — звичайні константи. Вони створюються під час компіляції, навіть якщо визначені як локальні у функціях, і можуть бути лише числами, символами (рунами), рядками або булевими виразами. Через обмеження часу компіляції, вирази, що їх визначають, повинні бути константними виразами, які обчислюються компілятором. Наприклад, `1<<3` є константним виразом, а `math.Sin(math.Pi/4)` — ні, оскільки виклик функції `math.Sin` має відбуватися під час виконання програми.

У Go перечислювані константи створюються за допомогою перечислювача `iota`. Оскільки `iota` може бути частиною виразу, а вирази можуть неявно повторюватися, легко створювати складні набори значень.
```go
type ByteSize float64

const (
    _           = iota // ігноруємо перше значення, присвоюючи його порожньому ідентифікатору
    KB ByteSize = 1 << (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
```

Можливість приєднати метод типу `String` до будь-якого типу, визначеного користувачем, дає змогу автоматично форматувати довільні значення для виведення. Хоча ви найчастіше бачите, як це застосовується до структур, ця техніка також корисна для скалярних типів, таких як типи з плаваючою комою, як от `ByteSize`.
```go
func (b ByteSize) String() string {
    switch {
    case b >= YB:
        return fmt.Sprintf("%.2fYB", b/YB)
    case b >= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b >= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b >= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b >= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b >= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b >= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b >= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}
```

Вираз `YB` виводиться як `1.00YB`, тоді як `ByteSize(1e13)` виводить `9.09TB`.

Використання `Sprintf` для реалізації методу `String` функції `ByteSize` є безпечним (дозволяє уникнути нескінченного повторення) не через перетворення, а через виклик `Sprintf` з `%f`, який не є рядковим форматом: `Sprintf` викликає метод `String` лише тоді, коли йому потрібен рядок, а `%f` — значення з плаваючою комою.

### Змінні
Змінні можна ініціалізувати так само як і константи, але ініціалізатором може бути загальний вираз, обчислений під час виконання програми.
```go
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
```

### Функція init
Наостанок, кожен файл може визначити власну ніладичну функцію `init` для налаштування необхідного стану. (Фактично, кожен файл може мати кілька функцій `init`.) І «наостанок» дійсно означає «наостанок»: функція `init` викликається після того, як всі змінних у пакеті було ініціалізовано, а ті, в свою чергу, ініціалізуються тільки після того, як всі імпортовані пакети були ініціалізовані.

Функція `init` часто використовується для перевірки або виправлення коректності стану програми перед початком реального виконання.
```go
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath може бути перевизначено за допомогою прапорця --gopath у командному рядку.
    flag.StringVar(&gopath, "gopath", gopath, "override default GOPATH")
}
```