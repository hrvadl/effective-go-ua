## Зміст
- [Методи](#Методи)
  - [Вказівники чи значення](#Вказівники-чи-значення)

## Методи

### Вказівники чи значення
Як ми бачили з `ByteSize` в [одному з минулих розділів](https://github.com/vladyslavpavlenko/effective-go-ua/blob/main/08.%20Ініціалізація.md#константи), методи можуть бути визначені для будь-якого іменованого типу (крім вказівника або інтерфейсу); а так званий «отримувач» не обов'язково повинен бути структурою.

В обговоренні [зрізів](https://github.com/vladyslavpavlenko/effective-go-ua/blob/main/07.%20Дані.md#Зрізи) ми власноруч написали функцію `Append`. Замість цього ми можемо визначити її як метод на зрізах. Для цього спочатку оголошуємо іменований тип, до якого ми можемо прив'язати метод, а потім робимо його приймачем для методу значення цього типу.
```go
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Тіло функції точно таке саме, як у функції Append, визначеній вище.
}
```
Це все одно вимагає того, щоб метод повертав оновлений зріз. Ми можемо усунути цю незручність, перевизначивши метод так, щоб він приймав _вказівник_ на `ByteSlice` як приймач, щоб метод міг напряму перезаписати зріз користувача.
```go
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Тіло, як вище, без повернення.
    *p = slice
}
```
Натомість ми можемо зробити ще краще. Якщо ми модифікуємо нашу функцію так, щоб вона виглядала як стандартний метод `Write`, ось так,
```go
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Знову ж таки, як вище.
    *p = slice
    return len(data), nil
}
```
то тип `*ByteSlice` задовольняти стандартний інтерфейс `io.Writer`, що дуже зручно. Наприклад, ми зможемо оформлювати виведення в один рядок.
```go
var b ByteSlice
fmt.Fprintf(&b, "This hour has %d days\n", 7)
```
Ми передаємо _адресу_ `ByteSlice`, тому що тільки `*ByteSlice` задовольняє `io.Writer`. Правило щодо вказівників та значень для приймачів полягає у тому, що методи значень можуть бути викликані як для вказівників, так і для значень, але методи вказівників можуть бути викликані _лише_ для вказівників.

Це правило виникає через те, що методи вказівника можуть модифікувати приймач; їх виклик для значення призведе до того, що метод отримає копію значення, тому будь-які зміни будуть відкинуті. Мова нівелює ймовірність цієї помилки. Однак існує зручний виняток. Коли значення є адресованим, мова піклується про загальний випадок виклику методу за вказівником на значення, автоматично вставляючи оператор адресування. У нашому прикладі змінна `b` є адресованою, тому ми можемо викликати її метод `Write` просто з `b.Write`. Компілятор перепише це в `(&b).Write` за нас.

До речі, ідея використання `Write` на зрізі байт є центральною в реалізації `bytes.Buffer`.