## Вкладення
Мова Go не надає типового, керованого типами поняття підкласів, але вона має можливість «запозичувати» частини реалізації, вбудовуючи типи в структуру або інтерфейс.

Вбудовування інтерфейсів дуже просте. Ми вже згадували інтерфейси `io.Reader` та `io.Writer` раніше; ось їх визначення.
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```
Це говорить саме про те, на що це схоже: `ReadWriter` може робити й те, що робить `Reader`, і те, що робить `Writer`; це об'єднання вбудованих інтерфейсів. Зауважте, що тільки інтерфейси можуть бути вбудовані в інші інтерфейси.

Та ж сама основна ідея застосовується до структур, але з більш далекосяжними наслідками. Пакет `bufio` має два типи структур, `bufio.Reader` і `bufio.Writer`, кожен з яких, звичайно, реалізує аналогічні інтерфейси з пакета `io`. Також `bufio` реалізує буферизований читач/записувач, що досягається шляхом об'єднання читача і записувача в одну структуру за допомогою вбудовування: він перераховує типи всередині структури, але не дає їм імен полів.

```go
// ReadWriter зберігає вказівники на Reader та Writer.
// Він реалізує io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
```

Вбудовані елементи є вказівниками на структури й, звичайно, повинні бути ініціалізовані перш ніж їх можна буде використовувати. Структуру `ReadWriter` можна записати так:
```go
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
```

але тоді, щоб просувати методи полів і задовольнити інтерфейси `io`, нам також потрібно буде надати методи перенаправлення, як це зроблено тут:
```go
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
```

Вбудовуючи структури безпосередньо, ми уникаємо цього. Методи вбудованих типів надаються заразом, а це означає, що `bufio.ReadWriter` не тільки має методи `bufio.Reader` і `bufio.Writer`, але й задовольняє всі три інтерфейси: `io.Reader`, `io.Writer` і `io.ReadWriter`.

Існує важлива відмінність між вбудовуванням та підкласами. Коли ми вбудовуємо тип, методи цього типу стають методами зовнішнього типу, але коли вони викликаються, отримувачем методу є внутрішній тип, а не зовнішній. У нашому прикладі, коли викликається метод `Read` типу `bufio.ReadWriter`, він має такий самий ефект, як і метод пересилання, описаний вище; отримувачем є поле для читання `ReadWriter`, а не сам `ReadWriter`.

Вбудовування також може бути просто зручнішим. У цьому прикладі показано вбудоване поле поряд зі звичайним іменованим полем.
```go
type Job struct {
    Command string
    *log.Logger
}
```

Тип `Job` тепер має `Print`, `Printf`, `Println` та інші методи `*log.Logger`. Звісно, ми могли б назвати поле `Logger`, але це не обов'язково. І тепер, після ініціалізації, ми можемо використовувати `Println` на `Job`:
```go
job.Println("starting now...")
```

`Logger` є просто полем структури `Job`, тому ми можемо ініціалізувати його звичайним чином всередині конструктора `Job`, ось так:
```go
func NewJob(command string, logger *log.Logger) *Job {
    return &Job{command, logger}
}
```
або з використанням складеного літерала:
```go
job := &Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
```

Якщо нам потрібно звернутися до вбудованого поля безпосередньо, ім'я типу поля, ігноруючи кваліфікатор пакета, слугує як ім'я поля, як це було у методі `Read` нашої структури `ReadWriter`. Тут, якби нам потрібно було отримати доступ до `*log.Logger` змінної `job`, ми б написали `job.Logger`, що було б корисно, якби ми хотіли вдосконалити методи `Logger`.
```go
func (job *Job) Printf(format string, args ...interface{}) {
    job.Logger.Printf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
```

Вкладення типів створює проблему конфлікту імен, але правила для її вирішення прості. По-перше, поле або метод `X` приховує будь-який інший елемент `X` у більш глибоко вкладеній частині типу. Якби `log.Logger` містив поле або метод з назвою `Command`, поле `Command` з `Job` домінувало б.

По-друге, якщо те саме ім'я з'являється на тому самому рівні вкладеності, це зазвичай є помилкою; було б помилково вбудовувати `log.Logger`, якщо структура `Job` містила б інше поле або метод з назвою `Logger`. Однак, якщо повторюване ім'я ніколи не згадується у програмі за межами визначення типу, все гаразд. Ця кваліфікація забезпечує певний захист від змін, внесених до типів, вбудованих ззовні; немає жодних проблем, якщо додано поле, яке конфліктує з іншим полем в іншому підтипі, якщо жодне з полів ніколи не використовується.