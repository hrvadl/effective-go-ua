# Ефективна Go (Effective Go)
Оригінал: [Effective Go](https://go.dev/doc/effective_go)

## Зміст
- [Вступ](#Вступ)
  - [Приклади](#Приклади)
- [Форматування](#Форматування)
- [Коментарі](#Коментарі)
- [Найменування](#Найменування)
  - [Назви пакетів](#Назви-пакетів)
  - [Геттери](#Геттери)
  - [Назви інтерфейсів](#Назви-інтерфейсів)
  - [MixedCaps](#MixedCaps)
- [Крапки з комою](#Крапки-з-комою)
- [Керуючі структури](#Керуючі-структури)
  - [If](#If)
  - [Перевизначення й переприсвоювання](#Перевизначення-й-переприсвоювання)
  - [For](#For)
  - [Switch](#Switch)
  - [Типізований switch](#Типізований-switch)
- [Функції](#Функції)
  - [Множинне повернення результатів](#Множинне-повернення-результатів)
  - [Найменування параметрів результату](#Найменування-параметрів-результату)
  - [Defer](#Defer)
- [Дані](#Дані)
  - [Створення за допомогою new](#Створення-за-допомогою-new)
  - [Конструктори та складені літерали](#Конструктори-та-складені-літерали)
  - [Створення за допомогою make](#Створення-за-допомогою-make)
  - [Масиви](#Масиви)
  - [Зрізи](#Зрізи)
  - [Двовимірні зрізи](#Двовимірні-зрізи)
  - [Карти](#Карти)
  - [Друк](#Друк)
  - [Приєднання](#Приєднання)
- [Ініціалізація](#Ініціалізація)
  - [Константи](#Константи)
  - [Змінні](#Змінні)
  - [Функція init](#Функція-init)
- [Методи](#Методи)
  - [Вказівники чи значення](#Вказівники-чи-значення)
- [Інтерфейси та інші типи](#Інтерфейси-та-інші-типи)
  - [Інтерфейси](#Інтерфейси)
  - [Перетворення](#Перетворення)
  - [Конвертація інтерфейсів та прив'язка типів](#Конвертація-інтерфейсів-і-прив'язка-типів)
  - [Загальність](#Загальність)
  - [Інтерфейси й методи](#Інтерфейси-й-методи)
- [Порожній ідентифікатор](#Порожній-ідентифікатор)
  - [Порожній ідентифікатор у множинному присвоюванні](#Порожній-ідентифікатор-у-множинному-присвоюванні)
  - [Невикористовувані імпортування й значення](#Невикористовувані-імпортування-й-значення)
  - [Імпортування для сторонніх ефектів](#Імпортування-для-сторонніх-ефектів)
  - [Перевірки інтерфейсів](#Перевірки-інтерфейсів)
- [Вкладення](#Вкладення)
- [Конкурентність](#Конкурентність)
  - [Розподіл за повідомленнями](#Розподіл-за-повідомленнями)
  - [Горутини](#Горутини)
  - [Канали](#Канали)
  - [Канали каналів](#Канали-каналів)
  - [Паралелізм](#Паралелізм)
  - [Поточний буфер](#Поточний-буфер)
- [Помилки](#Помилки)
  - [Паніка](#Паніка)
  - [Відновлення](#Відновлення)
- [Вебсервер](#Вебсервер)

## Вступ
Go — це нова мова. Запозичуючи ідеї з існуючих мов, вона  має й свої незвичайні властивості, які роблять ефективні програми на Go відмінними за характером від програм, написаних на подібних їй. Прямий переклад програм, написаних на C++ або Java, на Go навряд чи дасть задовільний результат — програми на Java написані на Java, а не на Go. З іншого боку, обдумування проблеми з перспективи Go може призвести до створення успішної, але зовсім іншої програми. Іншими словами, щоб добре писати на Go, важливо розуміти її властивості та ідіоми. Також важливо знати встановлені конвенції для програмування на Go, такі як найменування, форматування, побудова програм і так далі, щоб програми, які ви пишете, були зрозумілими для інших програмістів на Go.

Цей документ містить поради щодо написання зрозумілого, ідіоматичного коду мовою Go. Він доповнює [специфікацію мови](https://go.dev/ref/spec) (англ.), [«Тур із Go»](https://go-tour-ua-translation.lm.r.appspot.com/welcome/1) (укр.) та [«Як писати код на Go»](https://go.dev/doc/code) (англ.), які вам слід прочитати першими.

**Примітка, додана у січні 2022 року:** Цей документ було написано до випуску Go у 2009 році, і відтоді він суттєво не оновлювався. Хоча це хороший посібник для розуміння того, як користуватися самою мовою, завдяки стабільності мови, в ньому мало сказано про бібліотеки і нічого про значні зміни в екосистемі Go з моменту написання, такі як система збірки, тестування, модулі та поліморфізм. Ми не плануємо її оновлювати, оскільки змін було багато, а велика кількість документів, блогів та книг, що постійно зростає, чудово описують сучасне використання Go. Цей документ продовжує бути корисним, але ви повинні розуміти, що тут викладено далеко не всю інформацію. Додатковий контекст дивіться у [питанні 28782](https://github.com/golang/go/issues/28782).

### Приклади
Вихідні коди пакетів Go призначені не лише для використання у якості основної бібліотеки, але й як приклади використання мови. Більше того, багато пакетів містять робочі, самодостатні виконувані приклади, які ви можете запустити безпосередньо з вебсайту [go.dev](https://go.dev), наприклад, [цей](https://go.dev/pkg/strings/#example-Map) (якщо потрібно, натисніть на слово «Приклад», щоб відкрити його). Якщо у вас є питання про те, як підійти до проблеми або як щось можна реалізувати, документація, код і приклади в бібліотеці можуть надати відповіді, ідеї та підказки.

## Форматування
Питання форматування є найбільш суперечливими, але водночас найменш значущими. Люди можуть адаптуватися до різних стилів форматування, але краще, якщо їм взагалі не доведеться цього робити, і менше часу приділяється темі, якщо всі дотримуються одного стилю. Проблема полягає в тому, як підійти до цієї утопії без необхідності в довгому керівництві по стилю.

У Go ми застосовуємо незвичний підхід і дозволяємо машині подбати про більшість проблем форматування. Програма `gofmt` (також доступна як `go fmt`, яка працює на рівні пакетів, а не на рівні вихідного файлу) читає програму на Go і видає вихідний текст у стандартному стилі з відступами і вертикальним вирівнюванням, зберігаючи і, за необхідності, переформатовуючи коментарі. Якщо ви хочете дізнатися, як впоратися з якоюсь новою стилістичною ситуацією, запустіть `gofmt`; якщо відповідь не здається вам правильною, переробіть вашу програму (або повідомте про ваду в `gofmt`), а не обходьте її стороною.

Наприклад, не потрібно витрачати час на вирівнювання коментарів до полів структури, адже `gofmt` зробить це за вас. У наступному оголошенні
```go
type T struct {
    name string // name of the object
    value int // its value
}
```
`gofmt` самостійно вирівняє колонки:
```go
type T struct {
    name    string // name of the object
    value   int    // its value
}
```
Весь код Go у стандартних пакетах було відформатовано за допомогою `gofmt`.

Дуже коротко про деякі деталі форматування:

**Відступи**

Ми використовуємо табуляцію для відступів і `gofmt` робить це за замовчуванням. Використовуйте пробіли лише за крайньої необхідності.

**Довжина рядка**

Go не має обмежень на довжину рядка. Не хвилюйтеся про його перевонення. Якщо рядок здається вам занадто довгим, загорніть його і зробіть відступ за допомогою додаткової табуляції.

**Дужки**

Go потребує менше круглих дужок, ніж C та Java: керуючі структури (`if`, `for`, `switch`) не мають круглих дужок у своєму синтаксисі. Крім того, ієрархія пріоритетів операторів коротша і зрозуміліша, тому
```go
x<<8 + y<<16
```
не потребує додавання пробілів, на відміну від інших мов.

## Коментарі
У Go передбачено блокові коментарі у стилі C `/* */` та рядкові коментарі у стилі C++ `//`. Рядкові коментарі є нормою; блокові коментарі з'являються здебільшого як коментарі до пакетів, але можуть бути корисними всередині виразів або для вимкнення великих ділянок коду.

Коментарі, які з'являються перед оголошеннями верхнього рівня, без проміжних нових рядків, вважаються такими, що документують саме оголошення. Ці «doc-коментарі» є основною документацією для певного пакета або команди Go. Докладнішу інформацію про них наведено у розділі [«Doc-коментарі в Go»](https://go.dev/doc/comment) (англ.).

## Найменування
Найменування є так само важливими у Go, як і в будь-якій іншій мові. Вони навіть мають семантичний ефект: видимість імені поза пакетом визначається тим, чи є його перший символ верхнім регістром. Тому варто витратити трохи часу на розмову про угоди щодо іменування у програмах на Go.

### Назви пакетів
Коли пакет імпортовано, його назва використовується для отримання доступу до його вмісту. Після того, як пакет імпортовано,
```go
import "bytes"
```
пакет, що в свою чергу імпортує, може використовувати `bytes.Buffer`. Добре, якщо всі користувачі пакету можуть використовувати те саме ім'я для посилання на його вміст, а це означає, що ім'я пакету повинно бути гарним: коротким, лаконічним, таким, що викликає асоціації. За домовленістю, пакети мають назву з одного слова, написаного малими літерами; не слід використовувати підкреслення або mixedCaps. Зробіть ставку на стислість, оскільки всі, хто користуватиметься вашим пакетом, будуть багаторазово набирати цю назву. Але не турбуйтеся про унікальність імені. Ім'я пакета тільки за замовчуванням використовується під час імпорту; воно не повинно бути унікальним, і в рідкісних випадках, під час імпорту може бути вказано інше ім'я. У будь-якому разі, плутанина трапляється рідко, оскільки ім'я файлу в імпорті визначає, який саме пакет використовується.

Іншою домовленістю є те, що ім'я пакету є базовим ім'ям його вихідного каталогу; пакет у `src/encoding/base64` імпортується як `"encoding/base64"`, але має ім'я `base64`, а не, скажімо, `encoding_base64` чи `encodingBase64`.

Імпортер пакету використовуватиме назву для посилання на його вміст, тому експортовані назви у пакеті можуть використовувати цей факт, щоб уникнути повторень. (Не використовуйте нотацію `import .`, хоч це й, звісно, може спростити тести, що мають виконуватися поза пакетом, який вони тестують, але в інших випадках її слід уникати). Наприклад, тип буферизованого читача у пакеті `bufio` називається `Reader`, а не `BufReader`, оскільки користувачі сприймають його як `bufio.Reader`, що є зрозумілим і лаконічним іменем. Крім того, оскільки імпортовані об'єкти завжди адресуються за назвою пакету, `bufio.Reader` не конфліктує зі, скажімо, `io.Reader`. Аналогічно, функція для створення нових екземплярів `ring.Ring`, яка є визначеною як конструктор у Go, зазвичай називається `NewRing`, але оскільки `Ring` є єдиним типом, що експортується пакетом, і оскільки пакет називається `ring`, вона називається просто `New`, і користувачі пакету бачать її як `ring.New`. Використовуйте структуру пакетів для вибору вдалих назв.

Інший короткий приклад — функція `once.Do`; `once.Do(setup)` читається добре, і водночас краще не стане, якщо її перейменувати в щось накшталт `once.DoOrWaitUntilDone(setup)`. Довгі імена не роблять назви більш читабельними. У той час як коментарі можуть бути ціннішими, ніж довгі імена.

### Геттери
Go не надає автоматичної підтримки геттерів та сеттерів. Немає нічого поганого у тому, що ви самі визначаєте гетери та сетери, і це часто буває доречно, але додавати `Get` до імені геттера не є ні ідіоматичним, ні обов'язковим. Якщо у вас є поле, наприклад, `owner` (у нижньому регістрі, неекспортоване), метод геттера має називатися `Owner` (у верхньому регістрі, експортований), а не `GetOwner`. Використання імен у верхньому регістрі для експорту дозволяє відрізнити поле від методу. Метод сеттера, якщо у ньому є потреба, найімовірніше, називатиметься `SetOwner`. Обидві назви добре читаються на практиці:
```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Назви інтерфейсів
За домовленістю, однометодові інтерфейси називаються за назвою методу плюс суфікс `-er` або подібна модифікація для створення іменника-агента: `Reader`, `Writer`, `Formatter`, `CloseNotifier` тощо.

Існує низка таких назв, і продуктивно дотримуватися їх та назв функцій, які вони охоплюють. `Read`, `Write`, `Close`, `Flush`, `String` і так далі мають канонічні підписи і значення. Щоб уникнути плутанини, не давайте своєму методу одну з цих назв, якщо вона не має такої ж сигнатури і значення. І навпаки, якщо ваш тип реалізує метод з тим самим значенням, що і метод на якомусь відомому типі, дайте йому те саме ім'я і сигнатуру; називайте ваш метод перетворення рядка `String`, а не `ToString`.

### MixedCaps
Насамкінець, у Go прийнято використовувати `MixedCaps` або `mixedCaps`, а не підкреслення для написання назв, що складаються з кількох слів.

## Крапки з комою
Як і у C, формальна граматика Go використовує крапку з комою для поділу операцій-виразів, але на відміну від C, ці крапки не відображаються у вихідному коді. Натомість лексер використовує просте правило, щоб автоматично вставляти крапки з комою під час сканування, тому вхідний код здебільшого вільний від них.

Правило полягає у наступному. Якщо останньою лексемою перед новим рядком є ідентифікатор (зокрема такі слова, як `int` і `float64`), базовий літерал, наприклад, числова або рядкова константа, або одна з лексем: `break`, `continue`, `fallthrough`, `return`, `++`, `--`, `)`, `}`, лексер завжди вставляє крапку з комою після лексеми. Це можна підсумувати так: «якщо новий рядок стоїть після лексеми, яка може завершити вираз, вставити крапку з комою».

Крапку з комою також можна опустити безпосередньо перед закриваючою дужкою, тому вираз типу
```go
go func() { for { dst <- <-src } }()
```
не потребує крапки з комою. У програмах на ідіоматичній мові Go крапка з комою ставиться лише у таких місцях, як вираз циклу, для відокремлення ініціалізатора, умови та елементів продовження. Вони також необхідні для розділення кількох операторів у рядку, якщо ви пишете код таким чином.

Одним із наслідків правил вставки крапки з комою є те, що ви не можете переносити відкриваючу дужку керуючої структури (`if`, `for`, `switch` або `select`) на наступний рядок. Якщо ви це зробите, перед дужкою буде вставлено крапку з комою, що може призвести до небажаних наслідків. Пишіть так,
```go
if i < f() {
    g()
}
```
а не так:
```go
if i < f()  // помилка!
{           // помилка!
    g()
}
```

## Керуючі структури
Керуючі структури у Go подібні до таких у C, але відрізняються важливими особливостями. У Go немає циклу `do` або `while`, є лише дещо узагальнений `for`; `switch` є більш гнучким; `if` і `switch` приймають необов'язковий оператор ініціалізації, як і `for`; оператори `break` і `continue` приймають необов'язкову мітку для визначення того, що потрібно перервати або продовжити; і є нові керуючі структури, включаючи типізований `switch` і багатоканальний мультиплексор комунікацій, `select`. Синтаксис також дещо відрізняється: немає круглих дужок, а тіло завжди повинно бути розділене фігурними дужками.

### If
У Go простий if-вираз виглядає так:
```go
if x > 0 {
    return y
}
```
Обов'язкові дужки спрощують написання простих інструкцій `if` у декількох рядках. Так чи інакше, це гарний стиль, особливо коли тіло містить оператор керування, такий як `return` або `break`.

Оскільки `if` і `switch` допускають оператор ініціалізації, їх часто використовують для встановлення локальної змінної.
```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```
У бібліотеках Go ви побачите, що коли інструкція `if` не переходить у наступну інструкцію, тобто тіло закінчується `break`, `continue`, `goto` або `return`, непотрібна умова `else` опускається.
```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```
Нижче наведено приклад поширеної ситуації, коли код є захищеним від послідовності помилок. Код читається добре, якщо виконується без помилок, оминаючи випадки їх виникнення. Оскільки обробки помилок, як правило, закінчуються операторами `return`, то код не потребує використання операторів `else`.
```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

### Перевизначення й переприсвоювання
**Зауваження:** Останній приклад у попередньому розділі демонструє, як працює форма короткого оголошення `:=`. Оголошення, яке викликає `os.Open`, виглядає так,
```go
f, err := os.Open(name)
```
у цьому виразі оголошуються дві змінні, `f` та `err`. Кількома рядками пізніше йде виклик `f.Stat`,
```go
d, err := f.Stat()
```
який виглядає так, ніби він оголошує `d` та `err`. Зверніть увагу, що `err` з'являється в обох операторах. Це дублювання є законним: `err` оголошується в першому виразі, але лише _переприсвоюється_ в другому. Це означає, що виклик `f.Stat` використовує існуючу змінну `err`, оголошену вище, і просто присвоює їй нове значення.

В оголошенні `:=` змінна `v` може бути присутньою, навіть якщо вона вже була оголошена, за наступних умов:
- оголошення відбувається в тій же самій області видимості, що й наявна змінна `v` (якщо `v` уже оголошено за межами видимості, то оголошення створить нову змінну<sup>§</sup>)
- відповідне значення, під час ініціалізації, може бути присвоєно `v`
- існує хоча б одна нова змінна в оголошенні, яка буде створена заново

Ця незвичайна властивість — чиста практичність, яка слугує для використання однієї змінної `err`, наприклад, у довгому ланцюжку `if-else`. Ви побачите, що вона часто використовується.

<sup>§</sup>Варто зазначити, що у Go область видимості параметрів функції та значень, що повертаються, збігається з областю видимості тіла функції, хоча лексично вони знаходяться за межами фігурних дужок, що охоплюють тіло функції.

### For
Цикл `for` у Go схожий на відповідний цикл C, але він не є таким самим. Цей уніфікує `for` і `while`, але не містить `do-while`. Існує три форми, лише одна з яких має крапку з комою.
```go
// C-подібний for
for init; condition; post { }

// С-подібний while
for condition { }

// C-подібний for(;;)
for { }
```
Короткі оголошення дозволяють легко оголосити початкові умови прямо в циклі.
```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```
Якщо ви виконуєте цикл над масивом, зрізом, рядком або картою, або читаєте з каналу, то для керування циклом можна використати оператор `range`.
```go
for key, value := range oldMap {
    newMap[key] = value
}
```
Якщо вам потрібен лише перший елемент у _діапазоні_ (ключ або індекс), відкиньте другий:
```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```
Якщо вам потрібен лише другий елемент у _діапазоні_ (значення), використовуйте _порожній ідентифікатор_ (_), щоб відкинути перший:
```go
sum := 0
for _, value := range array {
    sum += value
}
```
Порожній ідентифікатор має багато сценаріїв використання та буде описаний у [подальшому розділі](#Порожній-ідентифікатор).

Для рядків `range` робить більше роботи за вас, зокрема виділяє окремі символи Unicode, виконуючи парсинг UTF-8. Помилкові кодування займають один байт і створюють руну (rune) заміни U+FFFD. (Назва (з відповідним вбудованим типом) руни є термінологією Go для одного символу Unicode. Детальніше дивіться у [специфікації мови](https://go.dev/ref/spec#Rune_literals) (англ.)). Цикл
```go
for pos, char := range "日本\x80語" { // \x80 не є коректним кодуванням UTF-8
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```
виводить
```
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

Наостанок, Go не має оператора `кома`, а `++` і `--` є інструкціями, а не виразами. Таким чином, якщо ви хочете використати декілька змінних в операторі `for`, вам слід скористатися паралельним присвоюванням (це виключає можливість використання `++` і `--`).
```go
// Обертання масиву a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch
У мові Go `switch` є більш узагальненим, ніж у C. Вирази не обов'язково мають бути константами або навіть цілими числами, умови перевіряються зверху-вниз до знаходження відповідності, і якщо `switch` не має виразів, то переходить у `true`. Отже, ідіоматично можливо записувати `if-else-if-else` ланцюжок як `switch`.
```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

Автоматичний пропуск умов відсутній, але, при цьому, вони можуть бути записані через кому:
```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Незважаючи на те, що вони не настільки поширені в Go, як у деяких інших C-подібних мовах, `break` може бути використаний для дострокового переривання `switch`. Хоча, іноді, треба перервати зовнішній (по відношенню до `switch`) цикл, а не сам `switch`, і в Go цього можна досягти шляхом додавання мітки перед циклом, і переходом до цієї мітки в разі виклику `break`. У наступному прикладі представлені обидва випадки:
```go
Loop:
    for n := 0; n < len(src); n += size {
        switch {
        case src[n] < sizeOne:
            if validateOnly {
                break
            }
            size = 1
            update(src[n])

        case src[n] < sizeTwo:
            if n+1 >= len(src) {
                err = errShortInput
                break Loop
            }
            if validateOnly {
                break
            }
            size = 2
            update(src[n] + src[n+1]<<shift)
        }
    }
```

Звичайно, інструкція `continue` також допускає використання міток, але це стосується лише циклів.

На завершення цього розділу наведемо процедуру порівняння фрагментів байтів, яка використовує два оператори `switch`:
```go
// Compare повертає ціле число, яке є результатом порівняння двох
// масивів байтів, лексикографічно.
// Результат буде 0, якщо a == b, -1, якщо a < b, і +1, якщо a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### Типізований switch
Оператор `switch` також можна використовувати для визначення динамічного типу інтерфейсних змінних. Таким чином, типізований `switch` використовує синтаксис перевірки типу з ключовим словом `type` у дужках. Якщо `switch` оголошує змінну у виразі, змінна матиме відповідний тип у кожному його пункті. Також ідіоматично повторно використовувати імена змінних у таких випадках, фактично оголошуючи нову змінну з тим самим іменем, але з іншим типом у кожному випадку.
```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T виводить тип змінної t
case bool:
    fmt.Printf("boolean %t\n", t)             // t має тип bool
case int:
    fmt.Printf("integer %d\n", t)             // t має тип int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t має тип *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t має тип *int
}
```

## Функції
### Множинне повернення результатів
Однією з незвичних особливостей Go є те, що функції та методи можуть повертати декілька значень водночас. Ця форма може бути використана для покращення кількох незграбних ідіом у програмах на C: повернення внутрішньосмугових помилок, таких як -1 для EOF та модифікація аргументу, переданого за адресою.

У мові C помилка запису сигналізується за допомогою негативного лічильника, а код помилки зберігається в нестабільній локації. У Go метод `Write` може одночасно повернути і лічильник, і помилку: «Так, ви записали деякі байти, але не всі, оскільки заповнили пристрій». Сигнатура методу `Write` для файлів з пакету `os` має вигляд:
```go
func (file *File) Write(b []byte) (n int, err error)
```
і, як зазначено у документації, даний метод повертає кількість записаних байт і ненульову помилку, якщо `n != len(b)`. Це поширений стиль; див. [розділ про обробку помилок](#Помилки) для отримання додаткових прикладів.

Подібний підхід позбавляє від необхідності передавати вказівник на значення, що повертається, для імітації параметра-посилання. Ось проста функція для отримання числа з позиції у зрізі байтів, яка повертає це число і наступну позицію.
```go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ { }
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

Ви можете використовувати його для сканування чисел у вхідному зрізі `b` таким чином:
```go
for i := 0; i < len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
```
