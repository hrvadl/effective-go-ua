## Зміст
- [Найменування](#Найменування)
  - [Назви пакетів](#Назви-пакетів)
  - [Геттери](#Геттери)
  - [Назви інтерфейсів](#Назви-інтерфейсів)
  - [MixedCaps](#MixedCaps)

## Найменування
Найменування є так само важливими у Go, як і в будь-якій іншій мові. Вони навіть мають семантичний ефект: видимість імені поза пакетом визначається тим, чи є його перший символ верхнім регістром. Тому варто витратити трохи часу на розмову про угоди щодо іменування у програмах на Go.

### Назви пакетів
Коли пакет імпортовано, його назва використовується для отримання доступу до його вмісту. Після того, як пакет імпортовано,
```go
import "bytes"
```
пакет, що своєю чергою імпортує, може використовувати `bytes.Buffer`. Добре, якщо всі користувачі пакета можуть використовувати те саме ім'я для посилання на його вміст, а це означає, що ім'я пакета повинно бути гарним: коротким, лаконічним, таким, що викликає асоціації. За домовленістю, пакети мають назву з одного слова, написаного малими літерами; не слід використовувати підкреслення або mixedCaps. Зробіть ставку на стислість, оскільки всі, хто користуватиметься вашим пакетом, будуть багаторазово набирати цю назву. Але не турбуйтеся про унікальність імені. Ім'я пакета тільки за замовчуванням використовується під час імпорту; воно не повинно бути унікальним, і в рідкісних випадках, під час імпорту може бути вказано інше ім'я. У будь-якому разі, плутанина трапляється рідко, оскільки ім'я файлу в імпорті визначає, який саме пакет використовується.

Іншою домовленістю є те, що ім'я пакета є базовим ім'ям його вихідного каталогу; пакет у `src/encoding/base64` імпортується як `"encoding/base64"`, але має ім'я `base64`, а не, скажімо, `encoding_base64` чи `encodingBase64`.

Імпортер пакета використовуватиме назву для посилання на його вміст, тому експортовані назви у пакеті можуть використовувати цей факт, щоб уникнути повторень. (Не використовуйте нотацію `import .`, хоч це й, звісно, може спростити тести, що мають виконуватися поза пакетом, який вони тестують, але в інших випадках її слід уникати). Наприклад, тип буферизованого читача у пакеті `bufio` називається `Reader`, а не `BufReader`, оскільки користувачі сприймають його як `bufio.Reader`, що є зрозумілим і лаконічним іменем. Крім того, оскільки імпортовані об'єкти завжди адресуються за назвою пакета, `bufio.Reader` не конфліктує зі, скажімо, `io.Reader`. Аналогічно, функція для створення нових екземплярів `ring.Ring`, яка є визначеною як конструктор у Go, зазвичай називається `NewRing`, але оскільки `Ring` є єдиним типом, що експортується пакетом, і оскільки пакет називається `ring`, вона називається просто `New`, і користувачі пакета бачать її як `ring.New`. Використовуйте структуру пакетів для вибору вдалих назв.

Інший короткий приклад — функція `once.Do`; `once.Do(setup)` читається добре, і водночас краще не стане, якщо її перейменувати в щось накшталт `once.DoOrWaitUntilDone(setup)`. Довгі імена не роблять назви більш читабельними. У той час як коментарі можуть бути ціннішими, ніж довгі імена.

### Геттери
Go не надає автоматичної підтримки геттерів та сеттерів. Немає нічого поганого у тому, що ви самі визначаєте гетери та сетери, і це часто буває доречно, але додавати `Get` до імені геттера не є ні ідіоматичним, ні обов'язковим. Якщо у вас є поле, наприклад, `owner` (у нижньому регістрі, неекспортоване), метод геттера має називатися `Owner` (у верхньому регістрі, експортований), а не `GetOwner`. Використання імен у верхньому регістрі для експорту дозволяє відрізнити поле від методу. Метод сеттера, якщо у ньому є потреба, найімовірніше, називатиметься `SetOwner`. Обидві назви добре читаються на практиці:
```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Назви інтерфейсів
За домовленістю, однометодові інтерфейси називаються за назвою методу плюс суфікс `-er` або подібна модифікація для створення іменника-агента: `Reader`, `Writer`, `Formatter`, `CloseNotifier` тощо.

Існує низка таких назв, і продуктивно дотримуватися їх та назв функцій, які вони охоплюють. `Read`, `Write`, `Close`, `Flush`, `String` і так далі мають канонічні підписи і значення. Щоб уникнути плутанини, не давайте своєму методу одну з цих назв, якщо вона не має такої ж сигнатури і значення. І навпаки, якщо ваш тип реалізує метод з тим самим значенням, що і метод на якомусь відомому типі, дайте йому те саме ім'я і сигнатуру; називайте ваш метод перетворення рядка `String`, а не `ToString`.

### MixedCaps
Насамкінець, у Go прийнято використовувати `MixedCaps` або `mixedCaps`, а не підкреслення для написання назв, що складаються з кількох слів.